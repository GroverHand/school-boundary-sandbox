<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>School Boundary Sandbox - Local Papa Fix</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <style>
    html, body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; }
    #map { height: 88vh; }
    #topbar { position:absolute; top:10px; left:10px; z-index:1000; background:white; padding:6px 8px;
              box-shadow:0 0 6px rgba(0,0,0,0.2); border-radius:4px; font-size:13px; }
    #progress { margin-top:6px; font-size:12px; color:#333; display:none; }
    .sidebar { position:absolute; top:10px; right:10px; z-index:1000; width:360px; max-height:88vh; overflow:auto;
               background:rgba(255,255,255,0.97); box-shadow:0 0 10px rgba(0,0,0,0.2); border-radius:6px; padding:10px 12px; font-size:13px; }
    .sidebar h3 { margin:0 0 6px 0; font-size:15px; }
    table { width:100%; border-collapse:collapse; font-size:12px; }
    table, th, td { border:1px solid #aaa; }
    th, td { padding:3px 4px; text-align:left; }
    .btn { display:inline-block; padding:4px 8px; margin:4px 2px 0 0; font-size:12px; cursor:pointer;
           background:#1976d2; color:white; border:none; border-radius:3px; }
    .btn:disabled { background:#999; cursor:default; }
    .section-title { margin:10px 0 4px 0; font-weight:bold; }
    #summary ul { margin:4px 0 8px 16px; padding:0; }
    #summary li { list-style:disc; }
    #toggleSummary { float:right; font-size:11px; background:#444; }
  </style>
</head>
<body>
<div id="topbar">
  <input type="file" id="csvFile" accept=".csv"/>
  <button class="btn" id="downloadSelected" disabled>Download Selected CSV</button>
  <div id="progress"></div>
</div>

<div id="map"></div>

<div class="sidebar" id="info" style="display:none;">
  <h3>Students in Selected Shape
    <button id="toggleSummary" class="btn" style="padding:2px 6px;">Hide Summary</button>
  </h3>
  <div id="counts"></div>
  <div id="summary"></div>
  <div id="tableContainer" style="margin-top:8px;"></div>
</div>

<!-- External libs (no document.write, all before app code) -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/papaparse@5.4.3/papaparse.min.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
// ====== Config ======
const DEFAULT_SUMMARY_CATEGORICAL = ['grade','school','PROGRAM','ELL','IEP'];
const DEFAULT_RATE_LIMIT_MS = 1100;
const CENTER = [46.8772, -96.7898];

// ====== Globals ======
let studentMarkers = [];
let studentRows = [];
let lastSelectionRows = [];
let drawnItemsGroup = L.featureGroup();

// ====== Map ======
const map = L.map('map').setView(CENTER, 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'&copy; OSM contributors' }).addTo(map);
drawnItemsGroup.addTo(map);

const drawControl = new L.Control.Draw({
  draw:{ polygon:true, rectangle:true, marker:false, circle:false, polyline:false, circlemarker:false },
  edit:{ featureGroup: drawnItemsGroup, edit:true, remove:true }
});
map.addControl(drawControl);

map.on(L.Draw.Event.CREATED, e => { drawnItemsGroup.addLayer(e.layer); recalcSelection(); });
map.on(L.Draw.Event.EDITED, recalcSelection);
map.on(L.Draw.Event.DELETED, recalcSelection);

// ====== CSV Load ======
document.getElementById('csvFile').addEventListener('change', e => {
  const file = e.target.files[0]; if(!file) return;
  Papa.parse(file, {
    header:true,
    dynamicTyping:false,
    skipEmptyLines:true,
    complete: async res => {
      clearMap();
      studentRows = res.data;
      if(!studentRows.length){ alert('CSV appears empty'); return; }
      const cols = Object.keys(studentRows[0]);
      const latKey = cols.find(c => /^(lat|latitude|y)$/i.test(c.trim()));
      const lonKey = cols.find(c => /^(lon|lng|longitude|x)$/i.test(c.trim()));
      if(latKey && lonKey){
        addMarkersFromLatLon(studentRows, latKey, lonKey);
        fitToMarkers();
        alert('Loaded ' + studentMarkers.length + ' points. Draw a polygon to select.');
      }else{
        const upper = cols.map(c=>c.toUpperCase());
        if(!['ADDRESS','CITY','STATE','ZIP'].every(c=>upper.includes(c))){
          alert('CSV must have LAT/LON (or X/Y) or ADDRESS,CITY,STATE,ZIP.');
          return;
        }
        const addrCol = cols[upper.indexOf('ADDRESS')];
        const cityCol = cols[upper.indexOf('CITY')];
        const stateCol= cols[upper.indexOf('STATE')];
        const zipCol  = cols[upper.indexOf('ZIP')];
        await geocodeAndAddMarkers(studentRows, addrCol, cityCol, stateCol, zipCol);
        fitToMarkers();
        alert('Loaded ' + studentMarkers.length + ' geocoded points. Draw a polygon to select.');
      }
    }
  });
});

function clearMap(){
  studentMarkers.forEach(m => map.removeLayer(m));
  studentMarkers = [];
  studentRows = [];
  lastSelectionRows = [];
  drawnItemsGroup.clearLayers();
  document.getElementById('info').style.display='none';
  document.getElementById('downloadSelected').disabled = true;
}

function addMarkersFromLatLon(rows, latKey, lonKey){
  rows.forEach(r => {
    const lat = parseFloat(r[latKey]);
    const lon = parseFloat(r[lonKey]);
    if(isFinite(lat) && isFinite(lon) && lat!==0 && lon!==0){
      const marker = L.circleMarker([lat, lon], {radius:4});
      marker.feature = r;
      marker.addTo(map);
      studentMarkers.push(marker);
    }
  });
}

function fitToMarkers(){
  if(studentMarkers.length){
    map.fitBounds(L.featureGroup(studentMarkers).getBounds().pad(0.1));
  }
}

async function geocodeAndAddMarkers(rows, addrK, cityK, stateK, zipK){
  const prog = document.getElementById('progress');
  prog.style.display='block';
  for(let i=0;i<rows.length;i++){
    prog.textContent = `Geocoding ${i+1} / ${rows.length}`;
    const r = rows[i];
    const addr = [r[addrK], r[cityK], r[stateK], r[zipK]].filter(Boolean).join(', ');
    try{
      const loc = await geocodeAddress(addr);
      if(loc){
        const marker = L.circleMarker([loc.lat, loc.lon], {radius:4});
        marker.feature = r;
        marker.addTo(map);
        studentMarkers.push(marker);
      }else{
        r.__geocode_failed = true;
      }
    }catch(err){ r.__geocode_failed = true; }
    await sleep(DEFAULT_RATE_LIMIT_MS);
  }
  prog.style.display='none';
}

async function geocodeAddress(q){
  const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&q=' + encodeURIComponent(q);
  const resp = await fetch(url, { headers:{'Accept-Language':'en'} });
  if(!resp.ok) return null;
  const json = await resp.json();
  if(!json.length) return null;
  return { lat: parseFloat(json[0].lat), lon: parseFloat(json[0].lon) };
}
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

// ====== Selection & Summary ======
function recalcSelection(){
  lastSelectionRows = [];
  if(!drawnItemsGroup.getLayers().length){
    document.getElementById('info').style.display='none';
    document.getElementById('downloadSelected').disabled = true;
    return;
  }
  const polys = drawnItemsGroup.getLayers().map(l => l.toGeoJSON());
  let unionPoly = null;
  polys.forEach(p=> unionPoly = unionPoly ? turf.union(unionPoly, p) : p);
  if(!unionPoly) return;

  studentMarkers.forEach(m => {
    const p = turf.point([m.getLatLng().lng, m.getLatLng().lat]);
    if(turf.booleanPointInPolygon(p, unionPoly)) lastSelectionRows.push(m.feature);
  });
  renderSelection();
}

function renderSelection(){
  const info = document.getElementById('info');
  const countsDiv = document.getElementById('counts');
  const tableDiv = document.getElementById('tableContainer');
  const summaryDiv = document.getElementById('summary');
  info.style.display='block';

  countsDiv.innerHTML = '<div class="section-title">Total selected: '+ lastSelectionRows.length +'</div>';

  if(!lastSelectionRows.length){
    tableDiv.innerHTML = '<p>No points inside shapes.</p>';
    summaryDiv.innerHTML = '';
    document.getElementById('downloadSelected').disabled = true;
    return;
  }

  const headers = Object.keys(lastSelectionRows[0]);
  let html = '<table><thead><tr>';
  headers.forEach(h => html += '<th>'+h+'</th>');
  html += '</tr></thead><tbody>';
  lastSelectionRows.forEach(r => {
    html += '<tr>';
    headers.forEach(h => html += '<td>'+ (r[h] ?? '') +'</td>');
    html += '</tr>';
  });
  html += '</tbody></table>';
  tableDiv.innerHTML = html;

  const cfg = deriveSummaryConfig(lastSelectionRows, headers);
  summaryDiv.innerHTML = buildSummaryHTML(lastSelectionRows, cfg);

  document.getElementById('downloadSelected').disabled = false;
}

function deriveSummaryConfig(rows, headers){
  const categorical = [];
  DEFAULT_SUMMARY_CATEGORICAL.forEach(c => {
    const found = headers.find(h => h.toLowerCase() === c.toLowerCase());
    if(found) categorical.push(found);
  });
  if(!categorical.length){
    headers.forEach(h => {
      if(h.startsWith('__')) return;
      const vals = rows.map(r=>r[h]).filter(v=>v!=='' && v!==undefined);
      if(!vals.length) return;
      const numeric = vals.every(v=>!isNaN(parseFloat(v)));
      const uniq = new Set(vals);
      if(!numeric && uniq.size>1 && uniq.size<=15) categorical.push(h);
    });
  }
  const numeric = headers.filter(h=>{
    const vals = rows.map(r=>r[h]).filter(v=>v!=='' && v!==undefined);
    if(!vals.length) return false;
    return vals.every(v=>!isNaN(parseFloat(v)));
  });
  return { categorical, numeric };
}

function buildSummaryHTML(rows, cfg){
  let html = '<div class="section-title">Summary</div>';
  cfg.categorical.forEach(col => {
    const freq = {};
    rows.forEach(r=>{ const v=r[col]??''; freq[v]=(freq[v]||0)+1; });
    html += '<div><strong>'+col+'</strong><ul>';
    Object.keys(freq).sort().forEach(k=> html += '<li>'+k+': '+freq[k]+'</li>');
    html += '</ul></div>';
  });
  cfg.numeric.forEach(col => {
    const vals = rows.map(r=>parseFloat(r[col])).filter(v=>!isNaN(v)).sort((a,b)=>a-b);
    if(!vals.length) return;
    const sum=vals.reduce((a,b)=>a+b,0);
    const mean=sum/vals.length;
    const median= vals.length%2===0 ? (vals[vals.length/2-1]+vals[vals.length/2])/2 : vals[Math.floor(vals.length/2)];
    html += '<div><strong>'+col+'</strong><ul>' +
            '<li>count: '+vals.length+'</li>' +
            '<li>mean: '+round(mean)+'</li>' +
            '<li>median: '+round(median)+'</li>' +
            '<li>min: '+round(vals[0])+'</li>' +
            '<li>max: '+round(vals[vals.length-1])+'</li>' +
            '</ul></div>';
  });
  return html;
}
function round(v){ return Math.round(v*100)/100; }

// ====== Export CSV ======
document.getElementById('downloadSelected').addEventListener('click', () => {
  if(!lastSelectionRows.length) return;
  const csv = Papa.unparse(lastSelectionRows);
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url;
  a.download='selection_'+new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')+'.csv';
  a.click();
  URL.revokeObjectURL(url);
});

// Toggle summary
document.getElementById('toggleSummary').addEventListener('click', () => {
  const s=document.getElementById('summary');
  if(s.style.display==='none'){ s.style.display='block'; document.getElementById('toggleSummary').textContent='Hide Summary'; }
  else { s.style.display='none'; document.getElementById('toggleSummary').textContent='Show Summary'; }
});
</script>
</body>
</html>
