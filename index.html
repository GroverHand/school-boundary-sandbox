<script>
/* === config === */
const DEFAULT_SUMMARY_CATEGORICAL = ['grade','school','PROGRAM','ELL','IEP'];
const DEFAULT_RATE_LIMIT_MS = 1100;
const CENTER = [46.8772, -96.7898];

/* === globals === */
let studentMarkers = [];
let studentRows = [];
let lastSelectionRows = [];
let drawnItemsGroup = L.featureGroup();

/* === map === */
const map = L.map('map').setView(CENTER, 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution:'&copy; OpenStreetMap contributors'
}).addTo(map);
drawnItemsGroup.addTo(map);

const drawControl = new L.Control.Draw({
  draw:{ polygon:true, rectangle:true, marker:false, circle:false, polyline:false, circlemarker:false },
  edit:{ featureGroup: drawnItemsGroup, edit:true, remove:true }
});
map.addControl(drawControl);

map.on(L.Draw.Event.CREATED, e => { drawnItemsGroup.addLayer(e.layer); recalcSelection(); });
map.on(L.Draw.Event.EDITED, recalcSelection);
map.on(L.Draw.Event.DELETED, recalcSelection);

/* === csv load === */
document.getElementById('csvFile').addEventListener('change', e => {
  const file = e.target.files[0]; if(!file) return;
  Papa.parse(file, {
    header:true, dynamicTyping:false, skipEmptyLines:true,
    complete: async res => {
      clearMap();
      studentRows = res.data;
      if(!studentRows.length){ alert('CSV appears empty'); return; }
      const cols = Object.keys(studentRows[0]);
      const latKey = cols.find(c => /^(lat|latitude|y)$/i.test(c.trim()));
      const lonKey = cols.find(c => /^(lon|lng|longitude|x)$/i.test(c.trim()));
      if(latKey && lonKey){
        addMarkersFromLatLon(studentRows, latKey, lonKey);
        fitToMarkers();
        alert('Loaded '+studentMarkers.length+' points. Draw a polygon to select.');
      }else{
        const u = cols.map(c=>c.toUpperCase());
        if(!['ADDRESS','CITY','STATE','ZIP'].every(c=>u.includes(c))){
          alert('CSV must have LAT/LON (or X/Y) or ADDRESS,CITY,STATE,ZIP.');
          return;
        }
        await geocodeAndAddMarkers(
          studentRows,
          cols[u.indexOf('ADDRESS')],
          cols[u.indexOf('CITY')],
          cols[u.indexOf('STATE')],
          cols[u.indexOf('ZIP')]
        );
        fitToMarkers();
        alert('Loaded '+studentMarkers.length+' geocoded points. Draw a polygon to select.');
      }
    }
  });
});

function clearMap(){
  studentMarkers.forEach(m => map.removeLayer(m));
  studentMarkers = [];
  studentRows = [];
  lastSelectionRows = [];
  drawnItemsGroup.clearLayers();
  document.getElementById('info').style.display='none';
  document.getElementById('downloadSelected').disabled = true;
}

function addMarkersFromLatLon(rows, latKey, lonKey){
  rows.forEach(r => {
    const lat = parseFloat(r[latKey]), lon = parseFloat(r[lonKey]);
    if(isFinite(lat) && isFinite(lon) && lat!==0 && lon!==0){
      const marker = L.circleMarker([lat, lon], {radius:4});
      marker.feature = r;
      marker.addTo(map);
      studentMarkers.push(marker);
    }
  });
}

function fitToMarkers(){
  if(studentMarkers.length){
    map.fitBounds(L.featureGroup(studentMarkers).getBounds().pad(0.1));
  }
}

async function geocodeAndAddMarkers(rows, addrK, cityK, stateK, zipK){
  const prog = document.getElementById('progress');
  prog.style.display='block';
  for(let i=0;i<rows.length;i++){
    prog.textContent = `Geocoding ${i+1} / ${rows.length}`;
    const r = rows[i];
    const addr = [r[addrK], r[cityK], r[stateK], r[zipK]].filter(Boolean).join(', ');
    try{
      const loc = await geocodeAddress(addr);
      if(loc){
        const marker = L.circleMarker([loc.lat, loc.lon], {radius:4});
        marker.feature = r;
        marker.addTo(map);
        studentMarkers.push(marker);
      }else{ r.__geocode_failed = true; }
    }catch(err){ r.__geocode_failed = true; }
    await sleep(DEFAULT_RATE_LIMIT_MS);
  }
  prog.style.display='none';
}

async function geocodeAddress(q){
  const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&q=' + encodeURIComponent(q);
  const resp = await fetch(url, { headers:{'Accept-Language':'en'} });
  if(!resp.ok) return null;
  const json = await resp.json();
  if(!json.length) return null;
  return { lat: parseFloat(json[0].lat), lon: parseFloat(json[0].lon) };
}
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* === selection & summary === */
function recalcSelection(){
  lastSelectionRows = [];
  if(!drawnItemsGroup.getLayers().length){
    document.getElementById('info').style.display='none';
    document.getElementById('downloadSelected').disabled = true;
    return;
  }
  const polys = drawnItemsGroup.getLayers().map(l=>l.toGeoJSON());
  let unionPoly = null;
  polys.forEach(p=> unionPoly = unionPoly ? turf.union(unionPoly, p) : p);
  if(!unionPoly) return;

  studentMarkers.forEach(m => {
    const p = turf.point([m.getLatLng().lng, m.getLatLng().lat]);
    if(turf.booleanPointInPolygon(p, unionPoly)) lastSelectionRows.push(m.feature);
  });
  renderSelection();
}

function renderSelection(){
  const info = document.getElementById('info');
  const countsDiv = document.getElementById('counts');
  const tableDiv  = document.getElementById('tableContainer');
  const summaryDiv= document.getElementById('summary');
  info.style.display='block';

  countsDiv.innerHTML = '<div class="section-title">Total selected: '+ lastSelectionRows.length +'</div>';

  if(!lastSelectionRows.length){
    tableDiv.innerHTML = '<p>No points inside shapes.</p>';
    summaryDiv.innerHTML = '';
    document.getElementById('downloadSelected').disabled = true;
    return;
  }

  const headers = Object.keys(lastSelectionRows[0]);
  let html = '<table><thead><tr>';
  headers.forEach(h => html += '<th>'+h+'</th>');
  html += '</tr></thead><tbody>';
  lastSelectionRows.forEach(r => {
    html += '<tr>';
    headers.forEach(h => html += '<td>'+ (r[h] ?? '') +'</td>');
    html += '</tr>';
  });
  html += '</tbody></table>';
  tableDiv.innerHTML = html;

  const cfg = deriveSummaryConfig(lastSelectionRows, headers);
  summaryDiv.innerHTML = buildSummaryHTML(lastSelectionRows, cfg);

  document.getElementById('downloadSelected').disabled = false;
}

function deriveSummaryConfig(rows, headers){
  const categorical = [];
  DEFAULT_SUMMARY_CATEGORICAL.forEach(c => {
    const found = headers.find(h => h.toLowerCase() === c.toLowerCase());
    if(found) categorical.push(found);
  });
  if(!categorical.length){
    headers.forEach(h => {
      if(h.startsWith('__')) return;
      const vals = rows.map(r=>r[h]).filter(v=>v!=='' && v!==undefined);
      if(!vals.length) return;
      const numeric = vals.every(v=>!isNaN(parseFloat(v)));
      const uniq = new Set(vals);
      if(!numeric && uniq.size>1 && uniq.size<=15) categorical.push(h);
    });
  }
  const numeric = headers.filter(h=>{
    const vals = rows.map(r=>r[h]).filter(v=>v!=='' && v!==undefined);
    if(!vals.length) return false;
    return vals.every(v=>!isNaN(parseFloat(v)));
  });
  return { categorical, numeric };
}

function buildSummaryHTML(rows, cfg){
  let html = '<div class="section-title">Summary</div>';
  cfg.categorical.forEach(col => {
    const freq = {};
    rows.forEach(r => { const v = r[col] ?? ''; freq[v] = (freq[v]||0)+1; });
    html += '<div><strong>'+col+'</strong><ul>';
    Object.keys(freq).sort().forEach(k => html += '<li>'+k+': '+freq[k]+'</li>');
    html += '</ul></div>';
  });
  cfg.numeric.forEach(col => {
    const vals = rows.map(r=>parseFloat(r[col])).filter(v=>!isNaN(v)).sort((a,b)=>a-b);
    if(!vals.length) return;
    const sum=vals.reduce((a,b)=>a+b,0);
    const mean=sum/vals.length;
    const median= vals.length%2===0 ? (vals[vals.length/2-1]+vals[vals.length/2])/2 : vals[Math.floor(vals.length/2)];
    html += '<div><strong>'+col+'</strong><ul>'+
            '<li>count: '+vals.length+'</li>'+
            '<li>mean: '+round(mean)+'</li>'+
            '<li>median: '+round(median)+'</li>'+
            '<li>min: '+round(vals[0])+'</li>'+
            '<li>max: '+round(vals[vals.length-1])+'</li>'+
            '</ul></div>';
  });
  return html;
}
function round(v){ return Math.round(v*100)/100; }

/* === export === */
document.getElementById('downloadSelected').addEventListener('click', () => {
  if(!lastSelectionRows.length) return;
  const csv = Papa.unparse(lastSelectionRows);
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url;
  a.download='selection_'+new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')+'.csv';
  a.click();
  URL.revokeObjectURL(url);
});

/* === summary toggle === */
document.getElementById('toggleSummary').addEventListener('click', () => {
  const s=document.getElementById('summary');
  if(s.style.display==='none'){ s.style.display='block'; this.textContent='Hide Summary'; }
  else { s.style.display='none'; this.textContent='Show Summary'; }
});
</script>
